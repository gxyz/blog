## 变量

Bash中没有数据类型。变量只能包含数字或者由一个或多个字符组成的字符串。

一共有三种变量:

- 局部变量
- 环境变量
- 作为位置参数的变量

### 局部变量

局部变量 是仅在某个脚本内部有效的变量。它们不能被其他的程序和脚本访问。

使用如下方式声明和使用, 注意: `=`左右不能有空格;

```
username="gxyz"  # 声明变量
echo $username   # 输出变量的值
unset $username  # 删除变量
```

可以用`local关键字声明`**属于某个函数的局部变量**:

```
local local_username="gxyz"   # 只在函数内部有效
```

### 环境变量

环境变量 是对当前shell会话内所有的程序或脚本都可见的变量。创建它们跟创建局部变量类似，但使用的是export关键字。

```
export GLOBAL_VAR="I'm a global variable"
```

bash中有很多环境变量, 常用表:

|Variable|	Description|
|---|---|
|$HOME|	当前用户的用户目录
|$PATH|	用分号分隔的目录列表，shell会到这些目录中查找命令
|$PWD|	当前工作目录
|$RANDOM|	0到32767之间的整数
|$UID|	数值类型，当前用户的用户ID
|$PS1|	主要系统输入提示符
|$PS2|	次要系统输入提示符

更全面的[环境变量列表](http://tldp.org/LDP/Bash-Beginners-Guide/html/sect_03_02.html#sect_03_02_04)

### 位置参数

位置参数 是在调用一个函数(或运行脚本)并传给它参数时创建的变量。如下表:

|参数|描述|
|---|---|
|$0|脚本名称|
|$1...$9|第1个到第9个参数列表|
|${10} … ${N}|第10个到N个参数列表|
|$* or $@|除了$0外的所有位置参数|
|$#|不包括$0在内的位置参数的个数|
|$FUNCTION|函数名称,仅在函数内部有效|

```bash
./script.sh foo bar
# $1 -> foo
# $2 -> bar
```

变量可以有 默认值。我们可以用如下语法来指定默认值：

```bash
# 如果变量为空，赋给他们默认值
: ${VAR:='default'}
: ${$1:='first'}

# 或者
FOO=${FOO:-'default'}
```

### 另外一些常用的特殊参数

|命令|描述|
|$?|上一条执行的命令的退出状态,可以用于判断某个操作是否执行成功|
|$$|获取到当前shell的进程ID|

## Shell扩展

扩展 发生在一行命令被分成一个个的 记号（tokens） 之后。换言之，扩展是一种执行数学运算的机制，还可以用来保存命令的执行结果

### 大括号扩展

大括号扩展让生成任意的字符串成为可能。它跟 文件名扩展 类似:

```bash
echo beg{i,a,u}n  # begin began begun
```

大括号扩展还可以用来创建一个可被循环迭代的区间。

```bash
echo {0..5} # 0 1 2 3 4 5
echo {00..8..2} # 00 02 04 06 08
```

### 命令置换

命令置换允许我们对一个命令求值，并将其值置换到另一个命令或者变量赋值表达式中。当一个命令被``或$()包围时，命令置换将会执行。

```bash
now=`date +%T`
# or
now=$(date +%T)

echo $now # 19:08:26
```

### 算数扩展

在bash中，执行算数运算是非常方便的。算数表达式必须包在`$(( ))`中, 并且使用变量时无需加`$`前缀。算数扩展的格式为：

```bash
result=$(( ((10 + 5*3) - 7) / 2 ))
result2=$(( result * 2 ))
echo $result # 9
echo $result2 # 18
```

### 单引号和双引号

单引号和双引号之间有很重要的区别。在双引号中，变量引用或者命令置换是会被展开的。在单引号中是不会的。

```bash
echo "Your home: $HOME" # Your home: /Users/<username>
echo 'Your home: $HOME' # Your home: $HOME
```

当局部变量和环境变量包含空格时，它们在引号中的扩展要格外注意.

```bash
INPUT="A string  with   strange    whitespace."
echo $INPUT   # A string with strange whitespace.
echo "$INPUT" # A string  with   strange    whitespace.
```

调用第一个echo时相当于给了它5个单独的参数 —— $INPUT被分成了单独的词，echo在每个词之间打印了一个空格。第二种情况，调用echo时只给了它一个参数（整个$INPUT的值，包括其中的空格）。

## 数组

bash中的数组变量给了你引用多个值的能力。在bash中，数组下标也是从0开始，也就是说，第一个元素的下标是0。

跟数组打交道时，要注意一个特殊的环境变量IFS。IFS，全称 Input Field Separator，保存了数组中元素的分隔符。它的默认值是一个空格IFS=' '。

### 声明数组

在bash中，可以通过简单地给数组变量的某个下标赋值来创建一个数组：

```bash
fruits[0]=Apple
fruits[1]=Pear
fruits[2]=Plum
```

数组变量也可以通过复合赋值的方式来创建，比如：

```bash
fruits=(Apple Pear Plum)
```

### 数组扩展

单个数组元素的扩展跟普通变量的扩展类似：

```bash
echo ${fruits[1]} # Pear
```

整个数组可以通过把数字下标换成*或@来扩展：

```bash
echo ${fruits[*]} # Apple Pear Plum
echo ${fruits[@]} # Apple Pear Plum
```

### 数组切片

除此之外，可以通过 切片 运算符来取出数组中的某一片元素：

```
echo ${fruits[@]:0:2} # Apple Desert fig
```

> ${fruits[@]}代表扩展为整个数组

### 向数组中添加元素

```bash
fruits=(Orange "${fruits[@]}" Banana Cherry)
echo ${fruits[@]} # Orange Apple Desert fig Plum Banana Cherry
```

相当于重新创建了一个数组, 覆盖到原变量上面

### 从数组上删除元素

用`unset`命令来从数组中删除一个元素：

```
unset fruits[0]
```

## 流, 管道以及序列

Bash有很强大的工具来处理程序之间的协同工作。使用流，我们能将一个程序的输出发送到另一个程序或文件.

管道给了我们创建传送带的机会，控制程序的执行成为可能。

### 流

Bash接收输入，并以字符序列或 字符流 的形式产生输出。这些流能被重定向到文件或另一个流中。

有三个文件描述符号:

|代码|描述符|描述|
|---|---|---|
|0|stdin|标准输入|
|1|stdout|标准输出|
|2|stderr|标准错误输出|

重定向让我们可以控制一个命令的输入来自哪里，输出结果到什么地方。这些运算符在控制流的重定向时会被用到：

|操作符|描述|
|---|---|
|`>`|重定向输出|
|`&>`|重定向输出和错误输出|
|`&>>`|以附加的形式重定向输出和错误输出|
|`<`|重定向输入|
|`<<`||
|`<<<`|Here字符串|


### 管道

我们不仅能将流重定向到文件中，还能重定向到其它程序中。**管道** 允许我们把一个程序的输出当做另一个程序的输入。

在下面的例子中，command1把它的输出发送给了command2，然后输出被传递到command3：

```
command1 | command2 | command3
```

这样的结构被称作 管道。

管道的返回值通常是管道中最后一个命令的返回值。shell会等到管道中所有的命令都结束后，才会返回一个值。如果你想让管道中任意一个命令失败后，管道就宣告失败，那么需要用下面的命令设置pipefail选项：

```
set -o pipefail
```

### 命令序列

命令序列是由;，&，&&或者||运算符分隔的一个或多个管道序列。

1. 如果一个命令以`&`结尾，shell将会在一个子shell中异步执行这个命令。换句话说，这个命令将会在后台执行。
2. 以`;`分隔的命令将会依次执行：一个接着一个。shell会等待直到每个命令执行完。
3. 以`&&`和`||`分隔的命令分别叫做 `与` 和 `或`序列。

```bash
# 当且仅当command1执行成功（返回0值）时，command2才会执行
command1 && command2

# 当且仅当command1执行失败（返回错误码）时，command2才会执行
command1 || command2
```

与 或 或 序列的返回值是序列中最后一个执行的命令的返回值。

## 条件语句

跟其它程序设计语言一样，Bash中的条件语句让我们可以决定一个操作是否被执行。结果取决于一个包在[[ ]]里的表达式。

条件表达式可以包含&&和||运算符，分别对应 与 和 或 。除此之外还有很多有用的[表达式](https://github.com/denysdovhan/bash-handbook/blob/master/translations/zh-CN/README.md#%E5%9F%BA%E5%85%83%E5%92%8C%E7%BB%84%E5%90%88%E8%A1%A8%E8%BE%BE%E5%BC%8F)。

共有两个不同的条件表达式：if和case。

### 基元和组合表达式

由`[[ ]]`（sh中是`[ ]`）包起来的表达式被称作 `检测命令` 或 `基元`。这些表达式帮助我们检测一个条件的结果。

跟文件系统相关:

|基元|含义|
|---|---|
|`[ -e FILE ]`|如果`FILE`存在 (exists)，为真|
|`[ -f FILE ]`|如果`FILE`存在 (exists)且是一个普通文件，为真|
|`[ -d FILE ]`|如果`FILE`存在 (exists)且是一个目录，为真|
|`[ -s FILE ]`|如果`FILE`存在 (exists)且非空(size大于0)，为真|
|`[ -r FILE ]`|如果`FILE`存在 (exists)且有读权限，为真|
